<?php

require_once 'views_data_export_exporter.inc';

/**
 * This exporter creates a DOC file readable by Microsoft Word.
 * The content is an HTML table, as used by the old XLS export mechanism.
 */
class ViewsDataExportExporterDOC extends ViewsDataExportExporter {
  /**
   * Regular expression that checks for a valid ISO 8601 date/time.
   */
  const DATE_REGEX_ANY = '/^((\d{4})(-(\d{2}))(-(\d{2})))?(([T \s]?(\d{2}))(:(\d{2}))(:(\d{2}))?)?$/';
  const DATE_REGEX_DATE = '/^((\d{4})(-(\d{2}))(-(\d{2})))$/';
  const DATE_REGEX_TIME = '/^(([T \s]?(\d{2}))(:(\d{2}))(:(\d{2}))?)?$/';

  function __construct($options) {
    $this->options = $options;

    parent::__construct($options);
  }

  function add_row(&$file_handle, $data, $row_count) {
    $row = $row_count + 1;
    $col = 'A';

    $output = '<row>';
    $utc_timezone = new DateTimeZone('UTC');
    foreach ($data as $key => $value) {
      $cell_position = $col . $row;
      if (empty($value) && strlen($value) === 0) {
        // Skip empty cells.
      }
      elseif (is_numeric($value)) {
        $output .= '<c r="' . $cell_position . '"><v>';
        $output .= $value;
        $output .= '</v></c>';
      }
      elseif (preg_match(self::DATE_REGEX_ANY, $value)) {
        // An Excel timestamp is the number of days since Jan 1, 1900, with
        // the decimal portion indicating the time (ddddd.tttttt).
        // To calculate, take the UNIX timestamp then add the number of days
        // between 1900 and 1970 (25568).
        $timestamp = date_timestamp_get(date_create($value, $utc_timezone));
        $excel_timestamp = ($timestamp / 86400) + 25568;

        // 1900 is treated as a leap year, but it is not. So all dates after
        // Feb 28, 1900 have one extra day added. That is "59" should be
        // March 1, 1900, but it's considered Feb 29, 1900, which didn't exist.
        // So all dates greater than 59 have 1 extra day added.
        // See http://www.cpearson.com/excel/datetime.htm.
        if ($excel_timestamp >= 59) {
          $excel_timestamp = $excel_timestamp + 1.0;
        }

        // Excel does not support dates prior to 0 (Jan 1, 1900). They have to
        // be represented as plain-text instead.
        if ($excel_timestamp <= 0) {
          $output .= '<c r="' . $cell_position . '" t="inlineStr"><is><t>';
          $output .= htmlspecialchars($value, ENT_QUOTES);
          $output .= '</t></is></c>';
        }
        // Now after calculating the Excel "timestamp", save it as a decimal
        // and point to a style formatter to make it appear as a date/time.
        else {
          // 1: Dates.
          // 2: Times.
          // 3: Date times.
          // These are tied to style definitions in the styles.xml file
          // generated by webform_exporter_excel_xlsx::xlsx_parts().
          if (preg_match(self::DATE_REGEX_DATE, $value)) {
            $style_format = 1;
          }
          elseif (preg_match(self::DATE_REGEX_TIME, $value)) {
            // Only take the time portion of time values.
            $excel_timestamp = $excel_timestamp - (int) $excel_timestamp;
            $style_format = 2;
          }
          else {
            $style_format = 3;
          }

          $output .= '<c r="' . $cell_position . '" s="' . $style_format . '"><v>';
          $output .= $excel_timestamp;
          $output .= '</v></c>';
        }
      }
      else {
        $output .= '<c r="' . $cell_position . '" t="inlineStr"' . (strpos($value, "\n") === FALSE ? '' : ' s="4"') . '><is><t>';
        $output .= htmlspecialchars($value, ENT_QUOTES);
        $output .= '</t></is></c>';
      }

      // Unbelievably, in PHP you can increment on letters. "Z"++ becomes "AA"
      // and "AA"++ becomes "AB", identical to Excel column names.
      $col++;
    }
    $output .= '</row>';
    $row++;

    @fwrite($file_handle, $output);
  }

  function bof(&$file_handle) {
    // Our beginning of file needs to include unknown data (the number of
    // columns and rows) at this point. Instead of writing the true BOF, we
    // output enough empty space to fill in the BOF later.
    // See webform_exporter_excel_xlsx::eof().
    $output = str_repeat(' ', 1024);
    @fwrite($file_handle, $output . "\n");
  }

  function eof(&$file_handle, $row_count, $col_count) {
    // We output a chunk of empty data in webform_exporter_excel_xlsx::bof()
    // to leave room for our real header, which includes the important
    // <dimension> tag. This is required for proper importing into Google Docs.

    // Convert column count to letter representation.
    $col = 'A';
    for ($n = 1; $n < $col_count; $n++) {
      $col++;
    }

    $bof = '';
    $bof .= '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' . "\n";
    $bof .= '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">';
    $bof .= '<dimension ref="A1:' . $col . $row_count . '"/>';
    $bof .= '<sheetData>';

    @fseek($file_handle, 0);
    @fwrite($file_handle, $bof);

    $eof = '';
    $eof .= '</sheetData>';
    $eof .= '</worksheet>';

    fseek($file_handle, 0, SEEK_END);
    fwrite($file_handle, $eof);
  }

  function post_process(&$results) {

  }

  function get_headers($filename) {
    $headers = parent::get_headers($filename);
    $headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    $headers['Content-Disposition'] = "attachment; filename=$filename.doc";
    return $headers;
  }

}
